import { Canvas, createCanvas, Image, loadImage } from "canvas";
import * as fs from "fs"
import path = require("path");

import { _ImageData } from "../../Canvas/interfaces/ImageData.interface";
import { NodeCanvasHandler } from "../../Canvas/NodeCanvasHandler";
import { GeneticImageIndividual } from "./GeneticImageIndividual";
import { GeneticImagePopulation } from "./GeneticImagePopulation";
import { RandomColoredCyclicQuad } from "./RandomColorCyclicQuad";


/** Binary quad solver main class */
export class GeneticImageSolver {
    populationSize:  number;  // Number of individuals in population
    individualSize:  number;  // Number of genes in each individual
    maxGeneration:   number;  // Max number of generations before stopping evolution
    mutationRate:    number;  // Population's muation rate
    steps:           number;  // Number of steps for generating final image
    refCanvasWidth:  number;  // Reference image's canvas width
    refCanvasHeight: number;  // Reference image's canvas height
    refCanvas:       Canvas;  // Reference image's canvas
    outputFolder:    string;  // Folder in which generated images will be written
    background:      Image;   // Background image
    strokes:         Image[]; // Pre-computed stroke images
    refHandler:      NodeCanvasHandler; // Reference image's canvas handler
    /**
     * Initializes population and creates reference image.
     * @param popSize population size
     * @param maxGen max number of generation to evolve
     * @param mutRate population's mutation rate
     * @param canvasWidth reference image width
     * @param canvasHeight reference image height
     * @param out output folder to write images
     */
    constructor(popSize: number, indivSize: number, maxGen: number, mutRate: number, steps: number, out: string) {
        this.populationSize  = popSize;
        this.individualSize  = indivSize;
        this.maxGeneration   = maxGen;
        this.mutationRate    = mutRate;
        this.steps           = steps;
        this.outputFolder    = out;
    }

    /** Creates the canvas background image */
    async createBackgroundCanvas(): Promise<void> {
        // Loads reference image
        const ref: Image = await loadImage(path.join(this.outputFolder, "ref.png"));
        this.refCanvasWidth = ref.width;
        this.refCanvasHeight = ref.height;
        // Converts reference image to canvas
        this.refCanvas = createCanvas(this.refCanvasWidth, this.refCanvasHeight);
        this.refHandler = new NodeCanvasHandler(this.refCanvas);
        this.refHandler.context.drawImage(ref, 0, 0)

        let lattestResult: Image;
        // Checks if a previous evolved image can be found, else a white background is created.
        if (fs.existsSync(path.join(this.outputFolder, "results", "result.png"))) {
            lattestResult = await loadImage(path.join(this.outputFolder, "results", "result.png"))
        } else {
            // Creates white canvas background
            let bgCanvas: Canvas = createCanvas(this.refCanvasWidth, this.refCanvasHeight);
            let bgHandler: NodeCanvasHandler = new NodeCanvasHandler(bgCanvas);
            bgHandler.beginPath();
            bgHandler.traceRectangle(0, 0, this.refCanvasWidth, this.refCanvasHeight);
            bgHandler.fill("white");
            // Stores the white background in file system as the lattest result
            const buffer: Buffer = bgCanvas.toBuffer("image/png");
            fs.writeFileSync(path.join(this.outputFolder, "results", "result.png"), buffer);
            lattestResult = await loadImage(path.join(this.outputFolder, "results", "result.png"));
        }

        this.background = lattestResult;
    }

    /**
     * Writes the image generated by the best individual phenotype
     * @param best best individual
     * @param gen current generation
     */
    saveBest(best: GeneticImageIndividual, gen: number) {
        // Creates canvas and canvas handler
        const canvas: Canvas = createCanvas(this.refCanvasWidth, this.refCanvasHeight);
        const canvasHandler: NodeCanvasHandler = new NodeCanvasHandler(canvas);
        canvasHandler.context.drawImage(this.background, 0, 0)
        for (let i = 0; i < best.size; i++) {
            let stroke = this.strokes[best.genes[i]];
            canvasHandler.context.drawImage(stroke, 0, 0);
        }

        // Writes the image to file system
        const buffer: Buffer = canvas.toBuffer("image/png");
        fs.writeFileSync(path.join(this.outputFolder, 'step', `${gen}.png`), buffer);
    }

    /**
     * Creates random stroke that will be available to generate the image
     * @param sizeCoef scalar to set the strokes size
     */
    async createStrokeImages(sizeCoef: number): Promise<void> {
        // Creates empty array to store pre-computed strokes
        this.strokes = [];
        // Creates a canvas to draw pre-computed strokes
        const strokeCnv: Canvas = new Canvas(this.refCanvasWidth, this.refCanvasHeight);
        const strokeCnvHandler: NodeCanvasHandler = new NodeCanvasHandler(strokeCnv);

        // Creates 300 random strokes images
        for (let i = 0; i < 300; i++) {
            // Creates random cyclic quad
            const quad: RandomColoredCyclicQuad = new RandomColoredCyclicQuad(
                this.refCanvasWidth,
                this.refCanvasHeight,
                Math.max(this.refCanvasWidth, this.refCanvasHeight) * sizeCoef,
                "hsla"
            );
            // Draws quad to canvas
            const points: number[][] = quad.points.map(p => [p.x, p.y]);
            strokeCnvHandler.context.clearRect(0, 0, this.refCanvasWidth, this.refCanvasHeight);
            strokeCnvHandler.beginPath();
            strokeCnvHandler.tracePath(points, true);
            strokeCnvHandler.fill(quad.color.toCssString());
            // Draws stroke canvas to image in file system
            const buffer: Buffer = strokeCnv.toBuffer("image/png");
            fs.writeFileSync(`${this.outputFolder}/strokes/${i}.png`, buffer);
            // Loads stroke as image
            let img = await loadImage(path.join(this.outputFolder, "strokes", `${i}.png`))
            this.strokes.push(img)
        }
    }

    /**
     * Evolves a population for as many generations as needed to complete one step
     * @param population population to evolve
     */
    evolveStepGenerations(population: GeneticImagePopulation): void {
        for (let i = 0; i <= this.maxGeneration; i++) {
            // Starts time to track execution time for one generation
            const start = Date.now();
            console.log('Generation', i);
            // Evolves population
            population.generate();
            // Retrieves current generation's best individual
            let best: GeneticImageIndividual = 
                population.solution !== undefined ?
                population.solution :
                [...population.individuals].sort((a, b) => a.fitness - b.fitness)[0];
            // Writes best individual's image to file system
            this.saveBest(best, i);
            console.log(`Generation ${i}: ${((Date.now() - start) * 0.001).toFixed(2)}\n`)
        }
    }

    /** Binary quads solver main function */
    solve(): void {
        const mainStart: number = Date.now(); // Used for execution time statistics
        const steps: number = 25;             // Number of steps for generating final image

        this.createBackgroundCanvas().then(async () => {
            // Scalar used to modify the size of the quads
            let initCoef: number = 1;
            for (let step = 1; step <= this.steps; step++) {
                let sizeCoef: number = initCoef / (step * 2);
                // Time tracker for one image step
                let drawStart = Date.now();
                await this.createStrokeImages(sizeCoef);
                // Loads background
                this.background = await loadImage(path.join(
                    this.outputFolder, "results", "result.png"
                ));

                // Creates a new population
                const population: GeneticImagePopulation = new GeneticImagePopulation(
                    this.populationSize,
                    this.refHandler.getImageData(0, 0, this.refCanvasWidth, this.refCanvasHeight),
                    this.mutationRate,
                    this.background,
                    this.strokes,
                    this.individualSize
                );
                
                // Spawns first generation
                population.spawn()
                this.evolveStepGenerations(population);
                fs.renameSync(
                    path.join(this.outputFolder, "results", "result.png"),
                    path.join(this.outputFolder, "results", `result${step}.png`)
                )
                fs.renameSync(
                    path.join(this.outputFolder, 'step', `${this.maxGeneration}.png`),
                    path.join(this.outputFolder, "results", "result.png")
                )

                console.log('TOTAL GENERATION: ', (Date.now() - drawStart) * 0.001)
            }
            console.log('FINAL: ', (Date.now() - mainStart) * 0.001);
            fs.rmSync(path.join(this.outputFolder, 'step'), { recursive: true, force: true });
            fs.rmSync(path.join(this.outputFolder, 'strokes'), { recursive: true, force: true });
        })
    }
}
