"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneticImageSolver = void 0;
const canvas_1 = require("canvas");
const fs = require("fs");
const path = require("path");
const NodeCanvasHandler_1 = require("../../Canvas/NodeCanvasHandler");
const GeneticImagePopulation_1 = require("./GeneticImagePopulation");
const RandomColorCyclicQuad_1 = require("./RandomColorCyclicQuad");
/** Binary quad solver main class */
class GeneticImageSolver {
    /**
     * Initializes population and creates reference image.
     * @param popSize population size
     * @param maxGen max number of generation to evolve
     * @param mutRate population's mutation rate
     * @param canvasWidth reference image width
     * @param canvasHeight reference image height
     * @param out output folder to write images
     */
    constructor(popSize, indivSize, maxGen, mutRate, steps, out) {
        this.populationSize = popSize;
        this.individualSize = indivSize;
        this.maxGeneration = maxGen;
        this.mutationRate = mutRate;
        this.steps = steps;
        this.outputFolder = out;
    }
    /** Creates the canvas background image */
    createBackgroundCanvas() {
        return __awaiter(this, void 0, void 0, function* () {
            // Loads reference image
            const ref = yield (0, canvas_1.loadImage)(path.join(this.outputFolder, "ref.png"));
            this.refCanvasWidth = ref.width;
            this.refCanvasHeight = ref.height;
            // Converts reference image to canvas
            this.refCanvas = (0, canvas_1.createCanvas)(this.refCanvasWidth, this.refCanvasHeight);
            this.refHandler = new NodeCanvasHandler_1.NodeCanvasHandler(this.refCanvas);
            this.refHandler.context.drawImage(ref, 0, 0);
            let lattestResult;
            // Checks if a previous evolved image can be found, else a white background is created.
            if (fs.existsSync(path.join(this.outputFolder, "results", "lattestResult.png"))) {
                lattestResult = yield (0, canvas_1.loadImage)(path.join(this.outputFolder, "results", "lattestResult.png"));
            }
            else {
                // Creates white canvas background
                let bgCanvas = (0, canvas_1.createCanvas)(this.refCanvasWidth, this.refCanvasHeight);
                let bgHandler = new NodeCanvasHandler_1.NodeCanvasHandler(bgCanvas);
                bgHandler.beginPath();
                bgHandler.traceRectangle(0, 0, this.refCanvasWidth, this.refCanvasHeight);
                bgHandler.fill("white");
                // Stores the white background in file system as the lattest result
                const buffer = bgCanvas.toBuffer("image/png");
                fs.writeFileSync(path.join(this.outputFolder, "results", "lattestResult.png"), buffer);
                lattestResult = yield (0, canvas_1.loadImage)(path.join(this.outputFolder, "results", "lattestResult.png"));
            }
            this.background = lattestResult;
        });
    }
    /**
     * Writes the image generated by the best individual phenotype
     * @param best best individual
     * @param gen current generation
     */
    saveBest(best, gen) {
        // Creates canvas and canvas handler
        const canvas = (0, canvas_1.createCanvas)(this.refCanvasWidth, this.refCanvasHeight);
        const canvasHandler = new NodeCanvasHandler_1.NodeCanvasHandler(canvas);
        canvasHandler.context.drawImage(this.background, 0, 0);
        for (let i = 0; i < best.size; i++) {
            let stroke = this.strokes[best.genes[i]];
            canvasHandler.context.drawImage(stroke, 0, 0);
        }
        // Writes the image to file system
        const buffer = canvas.toBuffer("image/png");
        fs.writeFileSync(`${this.outputFolder}/${gen}.png`, buffer);
    }
    /**
     * Creates random stroke that will be available to generate the image
     * @param sizeCoef scalar to set the strokes size
     */
    createStrokeImages(sizeCoef) {
        return __awaiter(this, void 0, void 0, function* () {
            // Creates empty array to store pre-computed strokes
            this.strokes = [];
            // Creates a canvas to draw pre-computed strokes
            const strokeCnv = new canvas_1.Canvas(this.refCanvasWidth, this.refCanvasHeight);
            const strokeCnvHandler = new NodeCanvasHandler_1.NodeCanvasHandler(strokeCnv);
            // Creates 300 random strokes images
            for (let i = 0; i < 300; i++) {
                // Creates random cyclic quad
                const quad = new RandomColorCyclicQuad_1.RandomColoredCyclicQuad(this.refCanvasWidth, this.refCanvasHeight, Math.max(this.refCanvasWidth, this.refCanvasHeight) * sizeCoef, "hsla");
                // Draws quad to canvas
                const points = quad.points.map(p => [p.x, p.y]);
                strokeCnvHandler.context.clearRect(0, 0, this.refCanvasWidth, this.refCanvasHeight);
                strokeCnvHandler.beginPath();
                strokeCnvHandler.tracePath(points, true);
                strokeCnvHandler.fill(quad.color.toCssString());
                // Draws stroke canvas to image in file system
                const buffer = strokeCnv.toBuffer("image/png");
                fs.writeFileSync(`${this.outputFolder}/strokes/${i}.png`, buffer);
                // Loads stroke as image
                let img = yield (0, canvas_1.loadImage)(path.join(this.outputFolder, "strokes", `${i}.png`));
                this.strokes.push(img);
            }
        });
    }
    /**
     * Evolves a population for as many generations as needed to complete one step
     * @param population population to evolve
     */
    evolveStepGenerations(population) {
        for (let i = 0; i <= this.maxGeneration; i++) {
            // Starts time to track execution time for one generation
            const start = Date.now();
            console.log('Generation', i);
            // Evolves population
            population.generate();
            // Retrieves current generation's best individual
            let best = population.solution !== undefined ?
                population.solution :
                [...population.individuals].sort((a, b) => a.fitness - b.fitness)[0];
            // Writes best individual's image to file system
            this.saveBest(best, i);
            console.log(`Generation ${i}: ${((Date.now() - start) * 0.001).toFixed(2)}\n`);
        }
    }
    /** Binary quads solver main function */
    solve() {
        const mainStart = Date.now(); // Used for execution time statistics
        const steps = 25; // Number of steps for generating final image
        this.createBackgroundCanvas().then(() => __awaiter(this, void 0, void 0, function* () {
            // Scalar used to modify the size of the quads
            let initCoef = 1;
            for (let step = 0; step < this.steps; step++) {
                let sizeCoef = initCoef / (step * 2);
                // Time tracker for one image step
                let drawStart = Date.now();
                yield this.createStrokeImages(sizeCoef);
                // Loads background
                this.background = yield (0, canvas_1.loadImage)(path.join(this.outputFolder, "results", "lattestResult.png"));
                // Creates a new population
                const population = new GeneticImagePopulation_1.GeneticImagePopulation(this.populationSize, this.refHandler.getImageData(0, 0, this.refCanvasWidth, this.refCanvasHeight), this.mutationRate, this.background, this.strokes, this.individualSize);
                // Spawns first generation
                population.spawn();
                this.evolveStepGenerations(population);
                fs.renameSync(path.join(this.outputFolder, "results", "lattestResult.png"), path.join(this.outputFolder, "results", `lattestResult${step}.png`));
                fs.renameSync(path.join(this.outputFolder, `${this.maxGeneration}.png`), path.join(this.outputFolder, "results", "lattestResult.png"));
                // if (sizeCoef >= 0.2)
                //     sizeCoef *= 0.5
                // else if (sizeCoef >= 0.01)
                //     sizeCoef -= 0.005
                // else sizeCoef *= 0.8
                path.join(this.outputFolder, "results", "best.png");
                console.log('TOTAL GENERATION: ', (Date.now() - drawStart) * 0.001);
            }
            console.log('FINAL: ', (Date.now() - mainStart) * 0.001);
        }));
    }
}
exports.GeneticImageSolver = GeneticImageSolver;
